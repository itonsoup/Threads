#include <iostream>
#include <thread>
#include <mutex>

using namespace std;

mutex mtx_parent;
mutex mtx_child;

void parent_thread()
{
    // Захватываем мьютекс родительского потока
    mtx_parent.lock();
    cout << "Родительский поток захватил свой мьютекс\n";

    // Пытаемся захватить мьютекс дочернего потока
    cout << "Родительский поток пытается захватить мьютекс дочернего потока\n";
    if (!mtx_child.try_lock()) {
        cout << "Родительский поток не смог захватить мьютекс дочернего потока из-за взаимной блокировки\n";
    }
    else {
        cout << "Родительский поток успешно захватил мьютекс дочернего потока\n";
        mtx_child.unlock();
    }
}

void child_thread()
{
    // Захватываем мьютекс дочернего потока
    mtx_child.lock();
    cout << "Дочерний поток захватил свой мьютекс\n";

    // Пытаемся захватить мьютекс родительского потока
    cout << "Дочерний поток пытается захватить мьютекс родительского потока\n";
    if (!mtx_parent.try_lock()) {
        cout << "Дочерний поток не смог захватить мьютекс родительского потока из-за взаимной блокировки\n";
    }
    else {
        cout << "Дочерний поток успешно захватил мьютекс родительского потока\n";
        mtx_parent.unlock();
    }
}

int main()
{
    setlocale(LC_ALL, "RU");
    // Сценарий 1: Потоки захватывают свои мьютексы, а затем пытаются захватить мьютексы друг друга
    cout << "Сценарий 1: Родительский поток сначала захватывает свой мьютекс, затем пытается захватить мьютекс дочернего потока\n";
    thread t1(parent_thread);
    thread t2(child_thread);
    t1.join();
    t2.join();
    cout << "Сценарий 1: Завершено\n\n";

    return 0;
}

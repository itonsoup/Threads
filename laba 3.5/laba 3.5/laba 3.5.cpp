#include <iostream>
#include <thread>
#include <semaphore.h>

using namespace std;

sem_t parent_sem;
sem_t child_sem;
int counter = 0; // переменная счетчика

void parent_thread()
{
    // Цикл увеличения счетчика и вывода его значения
    while (true) {
        sem_wait(&parent_sem); // Ожидаем разрешения от дочернего потока
        if (counter >= 10) // Проверяем условие завершения
            break;
        counter++; // Увеличиваем счетчик
        cout << "Значение счетчика: " << counter << " (родительский поток)" << endl; // Выводим значение счетчика
        sem_post(&child_sem); // Оповещаем дочерний поток
    }
}

void child_thread()
{
    // Цикл увеличения счетчика и вывода его значения
    while (true) {
        sem_wait(&child_sem); // Ожидаем разрешения от родительского потока
        if (counter >= 10) // Проверяем условие завершения
            break;
        counter++; // Увеличиваем счетчик
        cout << "Значение счетчика: " << counter << " (дочерний поток)" << endl; // Выводим значение счетчика
        sem_post(&parent_sem); // Оповещаем родительский поток
    }
}

//В этом коде оба потока синхронно увеличивают переменную counter и выводят ее значение. 
// Программа использует семафоры-счетчики для ожидания разрешения от другого потока перед выполнением операции увеличения счетчика и вывода значения.
//Теперь касательно доказательства, которое было представлено в задаче 12. 
// Это доказательство основано на взаимной блокировке при использовании двух мьютексов.
// Однако, поскольку семафоры-счетчики не используют мьютексы, а управляют доступом к ресурсу с помощью увеличения и уменьшения счетчика, они не подвержены проблеме взаимной блокировки, которая может возникнуть при использовании мьютексов.
// Таким образом, доказательство из задачи 12 не применимо к семафорам-счетчикам.

int main()
{
    setlocale(LC_ALL, "RU");
    // Инициализация семафоров
    sem_init(&parent_sem, 0, 1); // Родительский поток начинает
    sem_init(&child_sem, 0, 0); // Дочерний поток ожидает

    // Создание потоков
    thread t1(parent_thread);
    thread t2(child_thread);

    // Ожидание завершения потоков
    t1.join();
    t2.join();

    // Уничтожение семафоров
    sem_destroy(&parent_sem);
    sem_destroy(&child_sem);

    return 0;
}
